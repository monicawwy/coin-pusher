<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Royal Coin Pusher</title>
    <link rel="stylesheet" href="style.css">
    <link rel="manifest" href="manifest.json">
    <!-- å¼•å…¥ Matter.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

    <!-- èƒŒæ™¯è£é£¾ (ç´…å¸ƒç°¾èˆ‡ç‡ˆå…‰) -->
    <div class="bg-curtains"></div>
    <div class="bg-lights"></div>

    <!-- é ‚éƒ¨è€è™æ©Ÿ UI -->
    <div class="slot-machine-container">
        <div class="slot-header">
            <div class="jackpot-title">GRAND JACKPOT</div>
            <div class="jackpot-score">$ <span id="total-money">10,000</span></div>
        </div>
        <div class="slot-frame">
            <div class="reels-container">
                <div class="reel" id="reel1">ğŸ‘‘</div>
                <div class="reel" id="reel2">ğŸ’</div>
                <div class="reel" id="reel3">7ï¸âƒ£</div>
            </div>
            <div class="win-overlay" id="win-message">WIN!</div>
        </div>
    </div>

    <!-- éŠæˆ²ç‰©ç†ç•«å¸ƒ -->
    <div id="game-area">
        <!-- ç•«å¸ƒæœƒç”± JS è‡ªå‹•æ’å…¥é€™è£¡ -->
    </div>

    <!-- åº•éƒ¨æ§åˆ¶å€ -->
    <div class="controls">
        <div class="coin-balance">
            <div class="coin-icon"></div>
            <span id="score">0</span>
        </div>
        <button id="insert-btn" class="spin-button">
            <div class="inner-ring">
                <span>DROP</span>
            </div>
        </button>
    </div>

    <script>
        // --- éŸ³æ•ˆç³»çµ± ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'coin') {
                // é‡‘å¹£æ¸…è„†è²
                osc.type = 'square';
                osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(2000, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            } else if (type === 'push') {
                // æ©Ÿæ¢°è²
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'win') {
                // ä¸­çè²
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1);
                osc.start();
                osc.stop(audioCtx.currentTime + 1);
            }
        }

        // --- Matter.js ç‰©ç†å¼•æ“ ---
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Events = Matter.Events,
              Body = Matter.Body,
              Vector = Matter.Vector;

        // 1. è¨­å®šå¼•æ“
        const engine = Engine.create();
        const world = engine.world;
        
        // é‡é»ï¼šå°‡é‡åŠ›è¨­ç‚º 0 (å› ç‚ºæˆ‘å€‘æ˜¯ä¿¯è¦–è§’ï¼Œé‡‘å¹£æ˜¯å¹³èººçš„)
        // æˆ‘å€‘åªåœ¨é‡‘å¹£æ‰å‡ºé‚Šç·£æ™‚æ¨¡æ“¬é‡åŠ›
        engine.world.gravity.y = 0; 
        engine.world.gravity.x = 0;

        // 2. å°ºå¯¸è¨­å®š
        const width = window.innerWidth;
        const height = window.innerHeight * 0.65; // éŠæˆ²å€åŸŸä½”è¢å¹• 65%
        
        // 3. å»ºç«‹æ¸²æŸ“å™¨ (è‡ªå®šç¾©ï¼Œç‚ºäº†ç•«å‡ºæ©¢åœ“é€è¦–æ„Ÿ)
        const canvasContainer = document.getElementById('game-area');
        const render = Render.create({
            element: canvasContainer,
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false,
                background: 'transparent', // é€æ˜èƒŒæ™¯ï¼Œè®“ CSS ç¶ è‰²çµ¨å¸ƒé€å‡ºä¾†
                pixelRatio: window.devicePixelRatio
            }
        });

        // --- éŠæˆ²ç‰©ä»¶ ---

        // ç‰†å£ (ä¸å¯è¦‹ï¼Œé˜²æ­¢é‡‘å¹£å·¦å³è·‘å‡ºå»)
        const wallLeft = Bodies.rectangle(0, height/2, 20, height, { isStatic: true, render: { visible: false } });
        const wallRight = Bodies.rectangle(width, height/2, 20, height, { isStatic: true, render: { visible: false } });
        Composite.add(world, [wallLeft, wallRight]);

        // æ¨æ¿ (Pusher) - é€™æ˜¯éŠæˆ²çš„æ ¸å¿ƒ
        // æˆ‘å€‘å»ºç«‹ä¸€å€‹å·¨å¤§çš„æ–¹å¡Šåœ¨ä¸Šæ–¹ï¼Œå®ƒæœƒä¸Šä¸‹ç§»å‹• (æ¨¡æ“¬å‰å¾Œæ¨å‹•)
        const pusherWidth = width * 0.8;
        const pusherHeight = 150;
        const pusherYStart = 100;
        const pusher = Bodies.rectangle(width / 2, pusherYStart, pusherWidth, pusherHeight, {
            isStatic: true, // å®ƒæ˜¯éœæ…‹çš„(ä¸å—åŠ›)ï¼Œä½†æˆ‘å€‘æœƒæ‰‹å‹•ç§»å‹•å®ƒ
            label: 'pusher',
            render: {
                fillStyle: 'url(#pusherGradient)', // æš«æ™‚ç”¨é¡è‰²ï¼Œç¨å¾Œç”¨ Canvas ç¹ªåœ–è¦†è“‹
                visible: false // æˆ‘å€‘æœƒè‡ªå·±ç•«æ¨æ¿
            }
        });
        Composite.add(world, pusher);

        // éšœç¤™ç‰© (å…©å´çš„æ¥”å½¢ï¼Œè®“é‡‘å¹£å¾€ä¸­é–“æ“ )
        const wedgeLeft = Bodies.polygon(0, height - 100, 3, 80, { isStatic: true, angle: 0.5, render: { fillStyle: '#330000' }});
        const wedgeRight = Bodies.polygon(width, height - 100, 3, 80, { isStatic: true, angle: -0.5, render: { fillStyle: '#330000' }});
        // éš±è—å®ƒå€‘ï¼Œåªç”¨ç‰©ç†ç¢°æ’
        wedgeLeft.render.visible = false;
        wedgeRight.render.visible = false;
        Composite.add(world, [wedgeLeft, wedgeRight]);


        // --- é‚è¼¯è¿´åœˆ ---
        
        let time = 0;
        const pusherRange = 60; // æ¨å‹•è·é›¢
        const pusherSpeed = 0.03;

        Events.on(engine, 'beforeUpdate', function(event) {
            // 1. ç§»å‹•æ¨æ¿ (Sine Wave)
            time += pusherSpeed;
            const newY = pusherYStart + Math.sin(time) * pusherRange;
            Body.setPosition(pusher, { x: width/2, y: newY });

            // 2. æª¢æŸ¥é‡‘å¹£æ‰è½ (Win)
            // ç•«å¸ƒåº•éƒ¨æ˜¯ "é‚Šç·£"ã€‚å¦‚æœé‡‘å¹£ Y è¶…é heightï¼Œå°±ç®—æ‰ä¸‹å»
            const bodies = Composite.allBodies(world);
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (body.label === 'coin') {
                    // æ¨¡æ“¬æ‘©æ“¦åŠ› (è®“é‡‘å¹£å¾ˆå¿«åœä¸‹ä¾†ï¼Œä¸æœƒåƒå†°çƒä¸€æ¨£æ»‘)
                    Body.setVelocity(body, {
                        x: body.velocity.x * 0.96,
                        y: body.velocity.y * 0.96
                    });

                    // æª¢æŸ¥æ˜¯å¦æ‰å‡ºé‚Šç•Œ (ä¸‹æ–¹)
                    if (body.position.y > height + 30) {
                        addScore(1);
                        Composite.remove(world, body);
                    }
                }
            }
        });

        // --- è‡ªå®šç¾©æ¸²æŸ“ (é€è¦–é­”æ³•) ---
        // ç‚ºäº†è®“å®ƒçœ‹èµ·ä¾†åƒæˆªåœ–ï¼Œæˆ‘å€‘éœ€è¦æŠŠåœ“å½¢ç•«æˆæ©¢åœ“å½¢
        Events.on(render, 'afterRender', function() {
            const ctx = render.context;
            
            // 1. ç•«æ¨æ¿ (Pusher)
            // ç‚ºäº†ç«‹é«”æ„Ÿï¼Œæˆ‘å€‘ç•«ä¸€å€‹æ¢¯å½¢ç›’å­
            const pPos = pusher.position;
            const pBottom = pPos.y + pusherHeight/2;
            
            // æ¨æ¿é ‚éƒ¨
            const gradient = ctx.createLinearGradient(0, 0, width, 0);
            gradient.addColorStop(0, '#8B4513'); // æ·±éŠ…è‰²
            gradient.addColorStop(0.5, '#FFD700'); // é‡‘è‰²
            gradient.addColorStop(1, '#8B4513');

            ctx.fillStyle = gradient;
            
            // ç¹ªè£½æ¨æ¿æœ¬èº« (çœ‹èµ·ä¾†åƒå€‹åšç›’å­)
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 20;
            ctx.fillRect(pPos.x - pusherWidth/2, pPos.y - pusherHeight/2, pusherWidth, pusherHeight);
            ctx.shadowBlur = 0;

            // ç•«æ¨æ¿çš„å‰ç«¯äº®æ¢
            ctx.fillStyle = '#FFF8DC';
            ctx.fillRect(pPos.x - pusherWidth/2, pBottom - 10, pusherWidth, 10);

            // 2. ç•«é‡‘å¹£ (è¦†è“‹åŸæœ¬çš„ debug ç¹ªåœ–)
            const bodies = Composite.allBodies(world);
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            bodies.forEach(body => {
                if (body.label === 'coin') {
                    // å„²å­˜ç‹€æ…‹
                    ctx.save();
                    ctx.translate(body.position.x, body.position.y);
                    
                    // é€™è£¡æ˜¯å¤§çµ•æ‹›ï¼šç¸®æ”¾ Y è»¸ï¼ŒæŠŠåœ“è®Šæˆæ©¢åœ“ï¼Œè£½é€  3D é€è¦–æ„Ÿ
                    ctx.scale(1, 0.7); 

                    // é‡‘å¹£æœ¬é«”
                    const r = body.circleRadius;
                    
                    // é‡‘å¹£æ¼¸å±¤
                    const coinGrad = ctx.createRadialGradient(-r/2, -r/2, 2, 0, 0, r);
                    coinGrad.addColorStop(0, '#fffacd'); // äº®é»
                    coinGrad.addColorStop(0.5, '#ffd700'); // é‡‘
                    coinGrad.addColorStop(1, '#b8860b'); // æ·±é‡‘

                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, 2 * Math.PI);
                    ctx.fillStyle = coinGrad;
                    ctx.fill();

                    // é‡‘å¹£é‚Šæ¡†
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#DAA520';
                    ctx.stroke();

                    // é‡‘å¹£ä¸Šçš„åœ–æ¡ˆ (ç‹å† ç¬¦è™Ÿ)
                    ctx.fillStyle = 'rgba(184, 134, 11, 0.6)';
                    ctx.font = "bold 16px Arial";
                    ctx.fillText("â™›", 0, 2);

                    ctx.restore();
                }
            });
            
            // 3. ç•«å‰æ™¯é®ç½© (è®“é‡‘å¹£çœ‹èµ·ä¾†æ˜¯æ‰é€²æ´è£¡ï¼Œè€Œä¸æ˜¯ç›´æ¥æ¶ˆå¤±)
            ctx.fillStyle = 'linear-gradient(to top, rgba(0,0,0,0.8), transparent)';
        });

        // --- éŠæˆ²æ§åˆ¶ ---
        let score = 0;
        function addScore(val) {
            score += val;
            document.getElementById('score').innerText = score;
            playTone('coin'); // æ’­æ”¾å¾—åˆ†éŸ³æ•ˆ
        }

        // ç”¢ç”Ÿé‡‘å¹£
        function spawnCoin(x, y) {
            const coin = Bodies.circle(x, y, 18, { // é‡‘å¹£åŠå¾‘ 18
                label: 'coin',
                restitution: 0.2, // å½ˆæ€§ä½
                friction: 0.001, // æ‘©æ“¦åŠ›æ¥µä½ (æ»‘å‹•)
                frictionAir: 0.02, 
                density: 0.002,
                render: { visible: false } // éš±è—é è¨­ç¹ªåœ–ï¼Œæˆ‘å€‘ä¸Šé¢è‡ªå·±ç•«äº†
            });
            Composite.add(world, coin);
        }

        // åˆå§‹å¡«å……é‡‘å¹£
        function initCoins() {
            // éš¨æ©Ÿæ•£ä½ˆä¸€äº›é‡‘å¹£åœ¨æ¨æ¿å‰æ–¹
            for (let i = 0; i < 40; i++) {
                const x = (width/2 - 100) + Math.random() * 200;
                const y = (height/2) + Math.random() * 200;
                spawnCoin(x, y);
            }
        }

        // é»æ“ŠæŠ•å¹£ (Drop Coin)
        const dropBtn = document.getElementById('insert-btn');
        dropBtn.addEventListener('touchstart', handleDrop, {passive: false});
        dropBtn.addEventListener('click', handleDrop);

        let isSpinning = false;

        function handleDrop(e) {
            e.preventDefault(); // é˜²æ­¢é›™æ“Šç¸®æ”¾
            
            // è¦–è¦ºå›é¥‹
            dropBtn.classList.add('pressed');
            setTimeout(() => dropBtn.classList.remove('pressed'), 100);
            
            playTone('push');

            // åœ¨æ¨æ¿æ­£å‰æ–¹ç”Ÿæˆé‡‘å¹£
            // è¨ˆç®—æ¨æ¿ç•¶å‰ä½ç½®ï¼Œè®“é‡‘å¹£å‰›å¥½è½åœ¨æ¿å­å‰
            const dropX = (width/2 - 100) + Math.random() * 200; 
            const dropY = pusher.position.y + pusherHeight/2 + 20; // å‰›å¥½åœ¨æ¨æ¿å‰
            
            spawnCoin(dropX, dropY);

            // è§¸ç™¼è€è™æ©Ÿ (å¦‚æœæ²’æœ‰æ­£åœ¨è½‰)
            if (!isSpinning) {
                spinSlotMachine();
            }
        }

        // --- è€è™æ©Ÿé‚è¼¯ ---
        const reels = ['reel1', 'reel2', 'reel3'];
        const symbols = ['ğŸ‘‘', 'ğŸ’', '7ï¸âƒ£', 'ğŸ’', 'ğŸ””'];
        const winOverlay = document.getElementById('win-message');

        function spinSlotMachine() {
            isSpinning = true;
            winOverlay.style.opacity = '0';
            
            let spins = 0;
            const maxSpins = 20;
            
            const interval = setInterval(() => {
                reels.forEach(id => {
                    document.getElementById(id).innerText = symbols[Math.floor(Math.random() * symbols.length)];
                });
                spins++;
                if (spins >= maxSpins) {
                    clearInterval(interval);
                    checkWin();
                }
            }, 100);
        }

        function checkWin() {
            isSpinning = false;
            // 30% æ©Ÿç‡ä¸­ç
            if (Math.random() < 0.3) {
                // è¨­å®šå…¨éƒ¨ç›¸åŒç¬¦è™Ÿ
                const winSym = symbols[Math.floor(Math.random() * symbols.length)];
                reels.forEach(id => document.getElementById(id).innerText = winSym);
                
                // é¡¯ç¤ºä¸­çç‰¹æ•ˆ
                winOverlay.style.opacity = '1';
                winOverlay.classList.add('pop-in');
                playTone('win');

                // çå‹µï¼šå¾å¤©è€Œé™ä¸€å †é‡‘å¹£
                let rewardCount = Math.floor(Math.random() * 30) + 10; // 10~40 coins
                let dropCount = 0;
                
                const dropInterval = setInterval(() => {
                    const x = (width/2 - 50) + Math.random() * 100;
                    const y = pusher.position.y + pusherHeight/2 + 10;
                    spawnCoin(x, y);
                    dropCount++;
                    if(dropCount >= rewardCount) clearInterval(dropInterval);
                }, 100);

            }
        }

        // å•Ÿå‹•
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);
        initCoins();

    </script>
</body>
</html>
