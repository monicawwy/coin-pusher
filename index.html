<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Royal Casino Pusher</title>
    <link rel="stylesheet" href="style.css">
    <link rel="manifest" href="manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

    <!-- 1. èƒŒæ™¯è£é£¾ -->
    <div class="casino-bg"></div>

    <!-- 2. é ‚éƒ¨è€è™æ©Ÿ UI -->
    <div class="slot-machine-ui">
        <div class="jackpot-display">
            <span>GRAND JACKPOT</span>
            <div id="jackpot-val">$ 9,970.80</div>
        </div>
        <div class="slot-reels">
            <div class="reel-window">
                <div class="reel" id="r1">ğŸ‘¸</div>
                <div class="reel" id="r2">ğŸ‘¸</div>
                <div class="reel" id="r3">ğŸ‘¸</div>
            </div>
            <div id="win-msg">BONUS!</div>
        </div>
    </div>

    <!-- 3. éŠæˆ²ä¸»ç•«å¸ƒ -->
    <div id="game-container"></div>

    <!-- 4. åº•éƒ¨æ§åˆ¶å€ -->
    <div class="controls-bar">
        <div class="coin-info">
            <div class="coin-img"></div>
            <span id="score">0</span>
        </div>
        <button id="insert-btn" class="poker-chip-btn">
            <div class="chip-inner">
                <span>DROP</span>
            </div>
        </button>
    </div>

    <script>
        // --- éŸ³æ•ˆ ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'coin') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(1500, now);
                osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start();
                osc.stop(now + 0.1);
            } else if (type === 'win') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.5);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 1);
                osc.start();
                osc.stop(now + 1);
            }
        }

        // --- Matter.js ç‰©ç†æ ¸å¿ƒ ---
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Events = Matter.Events,
              Body = Matter.Body,
              Vector = Matter.Vector;

        const engine = Engine.create();
        const world = engine.world;

        // è¨­å®šï¼šé›–ç„¶æ˜¯ä¿¯è¦–è§’ï¼Œä½†æˆ‘å€‘çµ¦ä¸€å€‹å¾®å¼±çš„ Y é‡åŠ›ï¼Œæ¨¡æ“¬æ©Ÿå™¨æ–œå¡
        engine.world.gravity.y = 0.0; // é è¨­ç„¡é‡åŠ›ï¼Œæˆ‘å€‘æ‰‹å‹•æ§åˆ¶

        const width = window.innerWidth;
        const height = window.innerHeight * 0.75; // éŠæˆ²å€é«˜åº¦

        const render = Render.create({
            element: document.getElementById('game-container'),
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio
            }
        });

        // --- å ´æ™¯ä½ˆç½® (åƒç…§æˆªåœ–) ---

        // åƒæ•¸è¨­å®š
        const upperY = height * 0.4; // ä¸Šå±¤é«˜åº¦
        const upperWidth = width * 0.5; // ä¸Šå±¤è¼ƒçª„
        const lowerY = height * 0.95; // ä¸‹å±¤åº•éƒ¨
        
        // 1. éšœç¤™é»é» (Pegs) - ä½æ–¼é›¨åˆ·ä¸‹æ–¹
        const pegRows = 4;
        const pegStartY = 50;
        for(let i=0; i<pegRows; i++) {
            for(let j=0; j<6; j++) {
                let px = (width/2 - 100) + j * 40;
                if(i%2===0) px += 20;
                const peg = Bodies.circle(px, pegStartY + i*40, 4, {
                    isStatic: true,
                    render: { fillStyle: '#ffd700' },
                    restitution: 0.6
                });
                Composite.add(world, peg);
            }
        }

        // 2. æ¨æ¿ (Pushers)
        // é€™è£¡æ˜¯é—œéµï¼šæˆ‘å€‘å»ºç«‹ã€Œéš±å½¢ã€çš„ç‰©ç†æ¨æ¿ï¼Œè¦–è¦ºä¸Šç¨å¾Œç•«å‡ºä¾†
        
        // ä¸Šå±¤æ¨æ¿ (è¼ƒçª„)
        const pusher1 = Bodies.rectangle(width/2, upperY - 100, upperWidth, 60, {
            isStatic: true, // æˆ‘å€‘æ‰‹å‹•ç§»å‹•å®ƒ
            label: 'pusher1',
            render: { visible: false } 
        });

        // ä¸‹å±¤æ¨æ¿ (è¼ƒå¯¬)
        const pusher2 = Bodies.rectangle(width/2, height * 0.65, width, 60, {
            isStatic: true,
            label: 'pusher2',
            render: { visible: false }
        });

        // é‚Šç•Œç‰† (é˜²æ­¢éŠ€ä»”é£›å‡ºè¢å¹•å·¦å³)
        const walls = [
            Bodies.rectangle(-10, height/2, 20, height*2, { isStatic: true }),
            Bodies.rectangle(width+10, height/2, 20, height*2, { isStatic: true }),
            // åº•éƒ¨å›æ”¶å€ (å¾—åˆ†)
            Bodies.rectangle(width/2, height + 50, width, 50, { isStatic: true, isSensor: true, label: 'bucket' })
        ];

        Composite.add(world, [pusher1, pusher2, ...walls]);


        // --- éŠæˆ²é‚è¼¯è¿´åœˆ ---
        
        let time = 0;
        let wiperX = width/2;
        const wiperY = 20;
        
        Events.on(engine, 'beforeUpdate', function(event) {
            time += 0.02;

            // A. é›¨åˆ·ç§»å‹• (å·¦å³æ–æ“º)
            wiperX = (width/2) + Math.sin(time * 1.5) * (width * 0.3);

            // B. æ¨æ¿ç§»å‹• (æ´»å¡é‹å‹•)
            // ä¸Šå±¤
            const p1Y = (upperY - 60) + Math.sin(time) * 30;
            Body.setPosition(pusher1, { x: width/2, y: p1Y });

            // ä¸‹å±¤ (åç›¸)
            const p2Y = (height * 0.65) + Math.sin(time + 1.5) * 30;
            Body.setPosition(pusher2, { x: width/2, y: p2Y });

            // C. è‡ªå®šç¾©ç‰©ç†åŠ›å ´ (æ¨¡æ“¬æ–œå¡èˆ‡å…©å±¤çµæ§‹)
            const bodies = Composite.allBodies(world);
            bodies.forEach(body => {
                if (body.label === 'coin') {
                    // 1. æ¨¡æ“¬é‡åŠ› / æ–œå¡ä¸‹æ»‘
                    // å¦‚æœéŠ€ä»”åœ¨å¾ˆä¸Šé¢ (é›¨åˆ·å€)ï¼Œé‡åŠ›å¼·ä¸€é»è®“å®ƒå¿«æ‰
                    if (body.position.y < upperY - 50) {
                        Body.applyForce(body, body.position, { x: 0, y: 0.001 }); // å‚ç›´æ‰è½
                    } else {
                        // åœ¨å¹³å°ä¸Šï¼Œé‡åŠ›å¾ˆå¼± (æ¨¡æ“¬å¹³èººæ‘©æ“¦)
                        Body.applyForce(body, body.position, { x: 0, y: 0.0001 });
                        
                        // å¢åŠ é˜»å°¼ï¼Œè®“å®ƒä¸æœƒåƒæºœå†°ä¸€æ¨£
                        Body.setVelocity(body, { 
                            x: body.velocity.x * 0.95, 
                            y: body.velocity.y * 0.95 
                        });
                    }

                    // 2. æª¢æŸ¥æ˜¯å¦æ‰è½ä¸‹ä¸€å±¤
                    // æ‰å‡ºä¸‹å±¤ -> å¾—åˆ†
                    if (body.position.y > height + 20) {
                        addScore(1);
                        Composite.remove(world, body);
                    }
                }
            });
        });

        // --- ç¹ªåœ– (è¦–è¦ºé­”æ³•ï¼šæŠŠ 2D ç•«æˆæˆªåœ–çš„ 2.5D æ¨£å­) ---
        Events.on(render, 'afterRender', function() {
            const ctx = render.context;

            // 1. ç¹ªè£½ä¸‹å±¤ç¶ è‰²çµ¨å¸ƒå° (Green Felt) - æ¢¯å½¢é€è¦–
            ctx.globalCompositeOperation = 'destination-over'; // ç•«åœ¨é‡‘å¹£å¾Œé¢
            
            ctx.beginPath();
            // æ¢¯å½¢åº•éƒ¨
            ctx.moveTo(0, height);
            ctx.lineTo(width, height);
            // æ¢¯å½¢é ‚éƒ¨ (é€£æ¥ä¸Šå±¤)
            ctx.lineTo(width, height * 0.6);
            ctx.lineTo(0, height * 0.6);
            
            const gradGreen = ctx.createLinearGradient(0, height*0.6, 0, height);
            gradGreen.addColorStop(0, '#004d26'); // æ·±ç¶ 
            gradGreen.addColorStop(1, '#008040'); // äº®ç¶ 
            ctx.fillStyle = gradGreen;
            ctx.fill();
            
            // 2. ç¹ªè£½ä¸Šå±¤ç´«è‰²æ»‘é“ (Purple Ramp)
            ctx.beginPath();
            const rampX = (width - upperWidth) / 2;
            ctx.rect(rampX - 20, upperY - 50, upperWidth + 40, (height*0.6) - (upperY-50));
            const gradPurple = ctx.createLinearGradient(0, upperY, 0, height*0.6);
            gradPurple.addColorStop(0, '#4a0e4e'); // æ·±ç´«
            gradPurple.addColorStop(1, '#2a002e');
            ctx.fillStyle = gradPurple;
            ctx.fill();
            // é‡‘è‰²é‚Šæ¡†
            ctx.lineWidth = 5;
            ctx.strokeStyle = '#ffd700';
            ctx.stroke();

            // 3. ç¹ªè£½æ¨æ¿ (Pusher Blocks)
            // ä¸Šå±¤æ¨æ¿
            const p1Pos = pusher1.position;
            ctx.fillStyle = '#d4af37'; // é‡‘è‰²
            // ç•«ä¸€å€‹è“‹å­é®ä½å¾Œé¢ï¼Œè®“æ¨æ¿çœ‹èµ·ä¾†æ˜¯å¾ç‰†å£ä¼¸å‡ºä¾†çš„
            ctx.fillRect(rampX, upperY - 150, upperWidth, 100); // é®ç½©
            // ç•«æ¨æ¿æœ¬é«”
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'black';
            ctx.fillRect(p1Pos.x - upperWidth/2, p1Pos.y - 30, upperWidth, 60);
            ctx.shadowBlur = 0;
            
            // ä¸‹å±¤æ¨æ¿
            const p2Pos = pusher2.position;
            ctx.fillStyle = '#silver';
            const gradSilver = ctx.createLinearGradient(0, p2Pos.y-30, 0, p2Pos.y+30);
            gradSilver.addColorStop(0, '#fff');
            gradSilver.addColorStop(0.5, '#ccc');
            gradSilver.addColorStop(1, '#999');
            ctx.fillStyle = gradSilver;
            ctx.fillRect(0, p2Pos.y - 30, width, 60);

            // 4. ç¹ªè£½é›¨åˆ·
            ctx.globalCompositeOperation = 'source-over'; // ç•«åœ¨æœ€ä¸Šå±¤
            ctx.save();
            ctx.translate(wiperX, wiperY);
            
            // éœ“è™¹å…‰æ•ˆ
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            
            // ç®­é ­å½¢ç‹€
            ctx.beginPath();
            ctx.moveTo(-10, 0);
            ctx.lineTo(10, 0);
            ctx.lineTo(0, 25);
            ctx.fill();
            ctx.restore();
        });

        // --- ç”ŸæˆéŠ€ä»” ---
        function spawnCoin(x, y) {
            const coin = Bodies.circle(x, y, 14, {
                label: 'coin',
                restitution: 0.3,
                friction: 0.001, // æ¥µä½æ‘©æ“¦ï¼Œæ˜“æ–¼æ¨å‹•
                frictionAir: 0.02,
                render: {
                    fillStyle: '#ffd700',
                    strokeStyle: '#b8860b',
                    lineWidth: 2
                }
            });
            Composite.add(world, coin);
        }

        // åˆå§‹åŒ–ï¼šé‹ªæ»¿å…©å±¤
        function initCoins() {
            // ä¸Šå±¤ (ç´«è‰²å€)
            for(let i=0; i<30; i++) {
                const x = (width/2 - upperWidth/2 + 20) + Math.random() * (upperWidth - 40);
                const y = upperY + Math.random() * 100;
                spawnCoin(x, y);
            }
            // ä¸‹å±¤ (ç¶ è‰²å€)
            for(let i=0; i<50; i++) {
                const x = 20 + Math.random() * (width - 40);
                const y = height * 0.7 + Math.random() * 150;
                spawnCoin(x, y);
            }
        }

        // --- äº’å‹•é‚è¼¯ ---
        let score = 0;
        const scoreEl = document.getElementById('score');
        function addScore(v) {
            score += v;
            scoreEl.innerText = score;
            playSfx('coin');
        }

        const btn = document.getElementById('insert-btn');
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            
            // å‹•ç•«
            btn.classList.add('clicked');
            setTimeout(() => btn.classList.remove('clicked'), 100);

            // 1. å¾é›¨åˆ·ä½ç½®æ‰è½ (å¸¶æœ‰å‘ä¸‹é€Ÿåº¦)
            const coin = Bodies.circle(wiperX, wiperY + 30, 14, {
                label: 'coin',
                restitution: 0.5,
                render: { fillStyle: '#ffd700', strokeStyle: '#b8860b', lineWidth: 2 }
            });
            // çµ¦äºˆåˆé€Ÿåº¦ï¼Œç¢ºä¿å¿«é€Ÿé€šéé»é»å€
            Body.setVelocity(coin, { x: (Math.random()-0.5)*2, y: 5 });
            Composite.add(world, coin);

            // 2. å•Ÿå‹•è€è™æ©Ÿ
            spinSlot();
        });

        // è€è™æ©Ÿé‚è¼¯
        const reels = ['r1', 'r2', 'r3'];
        const icons = ['ğŸ‘¸','ğŸ’','7ï¸âƒ£','ğŸ’','ğŸ€'];
        const winMsg = document.getElementById('win-msg');
        let spinning = false;

        function spinSlot() {
            if(spinning) return;
            spinning = true;
            winMsg.style.opacity = 0;

            let count = 0;
            const timer = setInterval(() => {
                reels.forEach(id => {
                    document.getElementById(id).innerText = icons[Math.floor(Math.random()*icons.length)];
                });
                count++;
                if(count > 10) {
                    clearInterval(timer);
                    checkWin();
                }
            }, 80);
        }

        function checkWin() {
            spinning = false;
            if(Math.random() < 0.3) { // 30% win
                const sym = icons[Math.floor(Math.random()*icons.length)];
                reels.forEach(id => document.getElementById(id).innerText = sym);
                
                winMsg.style.opacity = 1;
                winMsg.innerText = "BIG WIN!";
                playSfx('win');
                
                // çå‹µï¼šä¸Šå±¤éš¨æ©Ÿæ‰è½
                let drops = 0;
                const dropT = setInterval(() => {
                    spawnCoin(width/2 + (Math.random()*100 - 50), upperY - 50);
                    drops++;
                    if(drops > 15) clearInterval(dropT);
                }, 100);
            }
        }

        // å•Ÿå‹•
        Render.run(render);
        Runner.run(Runner.create(), engine);
        initCoins();

        // ä¿®æ­£ç¡¬å¹£ç¹ªåœ– (å£“æ‰æˆæ©¢åœ“)
        Events.on(render, 'afterRender', () => {
            const ctx = render.context;
            const bodies = Composite.allBodies(world);
            
            bodies.forEach(b => {
                if(b.label === 'coin') {
                    ctx.save();
                    ctx.translate(b.position.x, b.position.y);
                    // æ ¹æ“š Y ä½ç½®æ±ºå®šå£“æ‰ç¨‹åº¦ï¼šä¸Šé¢åœ“ä¸€é»(æ‰è½)ï¼Œä¸‹é¢æ‰ä¸€é»(å¹³èºº)
                    let scaleY = 1;
                    if(b.position.y > upperY) scaleY = 0.6; // å¹³èºº
                    
                    ctx.scale(1, scaleY);
                    
                    ctx.beginPath();
                    ctx.arc(0, 0, 14, 0, Math.PI*2);
                    
                    const grad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 14);
                    grad.addColorStop(0, '#fff');
                    grad.addColorStop(0.5, '#ffd700');
                    grad.addColorStop(1, '#b8860b');
                    ctx.fillStyle = grad;
                    ctx.fill();
                    ctx.strokeStyle = '#b8860b';
                    ctx.stroke();
                    
                    // ç‹å† åœ–æ¨™
                    ctx.fillStyle = 'rgba(184,134,11, 0.5)';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('â™›', 0, 4);
                    
                    ctx.restore();
                }
            });
        });

    </script>
</body>
</html>
