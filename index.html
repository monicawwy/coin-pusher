<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Casino Coin Pusher</title>
    <link rel="stylesheet" href="style.css">
    <link rel="manifest" href="manifest.json">
    <!-- å¼•å…¥ Matter.js ç‰©ç†å¼•æ“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

    <!-- é ‚éƒ¨å°èˆª/ç‹€æ…‹åˆ— -->
    <header class="app-header">
        <div class="jackpot-display">
            JACKPOT: <span id="jackpot-amount">10,000</span>
        </div>
    </header>

    <!-- éŠæˆ²ä¸»ç•«å¸ƒ -->
    <div id="game-container"></div>

    <!-- è€è™æ©Ÿ UI -->
    <div class="slot-machine-overlay">
        <div class="slot-window">
            <div class="reel" id="reel1">ğŸ’</div>
            <div class="reel" id="reel2">7ï¸âƒ£</div>
            <div class="reel" id="reel3">ğŸ’</div>
        </div>
        <div id="slot-message">PUSH COIN!</div>
    </div>

    <!-- åº•éƒ¨æ§åˆ¶å€ -->
    <div class="controls-area">
        <div class="status-bar">
            <div>Coins Won: <span id="score">0</span></div>
        </div>
        <button id="drop-btn" class="casino-btn">
            <span>DROP COIN</span>
            <div class="shine"></div>
        </button>
    </div>

    <script>
        // --- éŸ³æ•ˆç³»çµ± (ä½¿ç”¨ Web Audio API ç”Ÿæˆç°¡å–®éŸ³æ•ˆï¼Œç„¡éœ€å¤–éƒ¨æª”æ¡ˆ) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'drop') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'win') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);
            }
        }

        // --- ç‰©ç†å¼•æ“è¨­å®š ---
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Events = Matter.Events,
              Body = Matter.Body;

        const engine = Engine.create();
        const world = engine.world;

        // æ‰‹æ©Ÿé©é…å°ºå¯¸
        const width = window.innerWidth;
        const height = window.innerHeight - 150; // ç•™å‡ºåº•éƒ¨æŒ‰éˆ•ç©ºé–“

        const render = Render.create({
            element: document.getElementById('game-container'),
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false,
                background: '#220033', // æ·±ç´«è³­å ´è‰²
                pixelRatio: window.devicePixelRatio // é«˜æ¸…æ¸²æŸ“
            }
        });

        // --- éŠæˆ²ç‰©ä»¶ ---

        // 1. é‚Šç•Œ
        const walls = [
            Bodies.rectangle(width / 2, height + 50, width, 100, { isStatic: true, label: 'floor', render: { visible: false } }), // åº•éƒ¨ (æ‰è½å€)
            Bodies.rectangle(-10, height / 2, 20, height, { isStatic: true, render: { fillStyle: '#444' } }), // å·¦ç‰†
            Bodies.rectangle(width + 10, height / 2, 20, height, { isStatic: true, render: { fillStyle: '#444' } }) // å³ç‰†
        ];
        Composite.add(world, walls);

        // 2. æ¨æ¿ (é›™å±¤è¨­è¨ˆ)
        // ä¸Šå±¤æ¨æ¿ (è¼ƒçª„ï¼Œç§»å‹•)
        const pusherUpper = Bodies.rectangle(width / 2, height * 0.3, width * 0.6, 40, {
            isStatic: true,
            render: { fillStyle: '#d4af37' } // é‡‘è‰²
        });
        // ä¸‹å±¤æ¨æ¿ (è¼ƒå¯¬ï¼Œç§»å‹•)
        const pusherLower = Bodies.rectangle(width / 2, height * 0.55, width * 0.8, 40, {
            isStatic: true,
            render: { fillStyle: '#c0c0c0' } // éŠ€è‰²
        });
        
        // å›ºå®šå¹³å° (æ‰¿æ¥ä¸Šå±¤æ‰ä¸‹ä¾†çš„éŠ€ä»”)
        const platformUpper = Bodies.rectangle(width / 2, height * 0.35, width * 0.6, 10, { 
            isStatic: true, 
            render: { fillStyle: '#550055' } 
        });
        const platformLower = Bodies.rectangle(width / 2, height * 0.6, width * 0.8, 10, { 
            isStatic: true, 
            render: { fillStyle: '#550055' } 
        });

        Composite.add(world, [pusherUpper, pusherLower, platformUpper, platformLower]);

        // 3. éšœç¤™é»é» (Plinko é¢¨æ ¼)
        const pegs = [];
        for (let i = 0; i < 5; i++) {
            for (let j = 0; j < 4; j++) {
                let x = (width / 2 - 60) + j * 40;
                let y = 50 + i * 30;
                if (i % 2 === 0) x += 20; // äº¤éŒ¯æ’åˆ—
                const peg = Bodies.circle(x, y, 4, {
                    isStatic: true,
                    render: { fillStyle: '#ff00ff' },
                    restitution: 0.8
                });
                pegs.push(peg);
            }
        }
        Composite.add(world, pegs);

        // --- é‚è¼¯èˆ‡å‹•ç•« ---
        
        // é›¨åˆ·é‚è¼¯ (Wiper)
        let wiperX = width / 2;
        let wiperSpeed = 3;
        const wiperRange = width * 0.4; // é›¨åˆ·ç§»å‹•ç¯„åœ

        // æ¨æ¿ç§»å‹•é‚è¼¯
        let time = 0;
        Events.on(engine, 'beforeUpdate', function(event) {
            time += 0.03;
            
            // é›¨åˆ·ç§»å‹•è¨ˆç®—
            wiperX = (width / 2) + Math.sin(time * 0.5) * wiperRange;

            // æ¨æ¿å‰å¾Œç§»å‹• (æ­£å¼¦æ³¢)
            // ä¸Šå±¤
            const px1 = width / 2; 
            const py1 = (height * 0.3) + Math.sin(time) * 30; 
            Body.setPosition(pusherUpper, { x: px1, y: py1 });
            
            // ä¸‹å±¤ (ç¨å¾®ä¸åŒæ­¥)
            const px2 = width / 2;
            const py2 = (height * 0.55) + Math.sin(time + 1) * 30;
            Body.setPosition(pusherLower, { x: px2, y: py2 });

            // æª¢æŸ¥æ‰è½å¾—åˆ†
            // é€™è£¡ç‚ºäº†ç°¡å–®ï¼Œå¦‚æœç‰©é«”æ‰å‡ºç•«é¢ä¸‹æ–¹ï¼Œç®—å¾—åˆ†
            const bodies = Composite.allBodies(world);
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (body.label === 'coin' && body.position.y > height + 20) {
                    addScore(1);
                    Composite.remove(world, body);
                }
            }
        });

        // ç”¢ç”ŸéŠ€ä»”å‡½æ•¸
        function spawnCoin(x, y, count = 1) {
            for(let i=0; i<count; i++) {
                setTimeout(() => {
                    const coin = Bodies.circle(x + (Math.random() * 10 - 5), y, 12, {
                        label: 'coin',
                        restitution: 0.3,
                        friction: 0.05,
                        render: {
                            fillStyle: '#FFD700', // é‡‘å¹£è‰²
                            strokeStyle: '#B8860B',
                            lineWidth: 2
                        }
                    });
                    Composite.add(world, coin);
                }, i * 100); // å¦‚æœå¤šå€‹ï¼Œç¨å¾®å»¶é²
            }
        }

        // é å…ˆå¡«æ»¿éŠ€ä»”
        function initCoins() {
            // ä¸Šå±¤
            for(let i=0; i<30; i++) {
                spawnCoin(width/2 + (Math.random()*100 - 50), height * 0.25);
            }
            // ä¸‹å±¤
            for(let i=0; i<40; i++) {
                spawnCoin(width/2 + (Math.random()*150 - 75), height * 0.5);
            }
        }

        // --- éŠæˆ²æ§åˆ¶èˆ‡è€è™æ©Ÿé‚è¼¯ ---
        let score = 0;
        const scoreEl = document.getElementById('score');
        
        function addScore(points) {
            score += points;
            scoreEl.innerText = score;
        }

        // è€è™æ©Ÿé‚è¼¯
        const reels = ['reel1', 'reel2', 'reel3'];
        const symbols = ['ğŸ’', '7ï¸âƒ£', 'ğŸ’', 'ğŸ””', 'ğŸ€'];
        const slotMessage = document.getElementById('slot-message');

        function triggerSlotMachine() {
            slotMessage.innerText = "SPINNING...";
            slotMessage.style.color = "#fff";
            
            // ç°¡å–®å‹•ç•«
            let spinInterval = setInterval(() => {
                reels.forEach(id => {
                    document.getElementById(id).innerText = symbols[Math.floor(Math.random() * symbols.length)];
                });
            }, 100);

            setTimeout(() => {
                clearInterval(spinInterval);
                checkWin();
            }, 1500);
        }

        function checkWin() {
            // è¨­å®š 30% ä¸­çç‡
            const isWin = Math.random() < 0.30; 
            
            if (isWin) {
                // éš¨æ©Ÿåœ–æ¡ˆä¸€è‡´ (è¦–è¦ºæ•ˆæœ)
                const winSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                reels.forEach(id => document.getElementById(id).innerText = winSymbol);
                
                slotMessage.innerText = "BIG WIN!";
                slotMessage.style.color = "#ff0055";
                playSound('win');

                // æ±ºå®šçå‹µ (20 - 1000)
                // ä½¿ç”¨æ¬Šé‡ï¼šå¤§éƒ¨åˆ†æ™‚å€™æ˜¯å°çï¼Œå¶çˆ¾å¤§ç
                let reward = 20;
                const r = Math.random();
                if (r > 0.95) reward = 1000;
                else if (r > 0.8) reward = 100;
                else if (r > 0.5) reward = 50;
                else reward = 20;

                slotMessage.innerText = `WIN: ${reward} COINS!`;
                
                // æ‰è½éŠ€ä»”
                // é™åˆ¶ï¼šç‚ºäº†ç€è¦½å™¨æ•ˆèƒ½ï¼Œå¦‚æœæ•¸å­—å¤ªå¤§ï¼Œåˆ†æ‰¹æ‰è½æˆ–è¦–è¦ºç°¡åŒ–
                const actualDrops = Math.min(reward, 100); // ç‰©ç†ä¸Šé™é˜²å¡é “
                spawnCoin(width / 2, 50, actualDrops);

            } else {
                slotMessage.innerText = "TRY AGAIN";
                reels.forEach(id => {
                    document.getElementById(id).innerText = symbols[Math.floor(Math.random() * symbols.length)];
                });
            }
        }

        // æŒ‰éˆ•äº‹ä»¶
        document.getElementById('drop-btn').addEventListener('click', (e) => {
            // è¦–è¦ºå›é¥‹
            const btn = e.currentTarget;
            btn.style.transform = "scale(0.95)";
            setTimeout(() => btn.style.transform = "scale(1)", 100);

            playSound('drop');

            // å¾é›¨åˆ·ä½ç½®æ‰è½
            spawnCoin(wiperX, 0, 1);
            
            // å•Ÿå‹•è€è™æ©Ÿ
            triggerSlotMachine();
        });

        // å•Ÿå‹•
        Render.run(render);
        Runner.run(Runner.create(), engine);
        initCoins();

        // ç¹ªè£½é›¨åˆ· (ä½¿ç”¨ Matter.js çš„ afterRender)
        Events.on(render, 'afterRender', function() {
            const ctx = render.context;
            ctx.fillStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(wiperX, 30, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // ç•«å€‹å°ç®­é ­å‘ä¸‹
            ctx.beginPath();
            ctx.moveTo(wiperX - 5, 30);
            ctx.lineTo(wiperX + 5, 30);
            ctx.lineTo(wiperX, 45);
            ctx.fill();
        });

    </script>
</body>
</html>
